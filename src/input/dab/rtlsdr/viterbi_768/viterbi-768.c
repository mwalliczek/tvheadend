#
/*
 *    Copyright (C) 2013
 *    Jan van Katwijk (J.vanKatwijk@gmail.com)
 *    Lazy Chair Computing
 *
 *    This file is part of the Qt-DAB
 *    Qt-DAB is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    Qt-DAB is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with Qt-DAB; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *	The convolutional decoder for the FIC blocks has fixed sized
 *	blocks, so we can use pre-generated code - for that specific
 *	sized blocks - generated by the spiral project
 */
#include "../dab.h"
#include "tvheadend.h"
#include	<malloc.h>
#include	"viterbi-768.h"
#ifdef  __MINGW32__
#include <intrin.h>
// #include <malloc.h>
#include <windows.h>
#endif

//
//	It took a while to discover that the polynomes we used
//	in our own "straightforward" implementation was bitreversed!!
//	The official one is on top.
#define VITERBI_K 7
#define POLYS { 0155, 0117, 0123, 0155}
//#define	POLYS	{109, 79, 83, 109}
// In the reversed form the polys look:
//#define POLYS { 0133, 0171, 0145, 0133 }
//#define POLYS { 91, 121, 101, 91 }

#define	METRICSHIFT	0
#define	PRECISIONSHIFT	0
#define	RENORMALIZE_THRESHOLD	137

//
/* ADDSHIFT and SUBSHIFT make sure that the thing returned is a byte. */
#if (VITERBI_K-1<8)
#define ADDSHIFT (8-(VITERBI_K-1))
#define SUBSHIFT 0
#elif (VITERBI_K-1>8)
#define ADDSHIFT 0
#define SUBSHIFT ((VITERBI_K-1)-8)
#else
#define ADDSHIFT 0
#define SUBSHIFT 0
#endif

static COMPUTETYPE Branchtab[NUMSTATES / 2 * RATE] __attribute__((aligned(16)));
int	parity(int);
void	init_viterbi(struct v *, int16_t);
void	update_viterbi_blk_SPIRAL(struct v *, COMPUTETYPE *,
	int16_t);
void	chainback_viterbi(struct v *, int16_t, uint16_t);

static uint8_t Partab [] = 
{ 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
  1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
  1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
  0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
  1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
  0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
  1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
  1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
  0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
  0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
  1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
  0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
  1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
  1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
  0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0};

int 	parity (int x){
	/* Fold down to one byte */
	x ^= (x >> 16);
	x ^= (x >> 8);
	return Partab [x];
}

static inline
void	renormalize (COMPUTETYPE* X, COMPUTETYPE threshold){
int32_t	i;

	if (X [0] > threshold){
	   COMPUTETYPE min = X [0];
	   for (i = 0; i < NUMSTATES; i++)
	      if (min > X[i])
	         min = X[i];
	   for (i = 0; i < NUMSTATES; i++)
	      X[i] -= min;
      }
}

void initConstViterbi768(void) {
int polys [RATE] = POLYS;
int16_t	i, state;
	for (state = 0; state < NUMSTATES / 2; state++) {
	   for (i = 0; i < RATE; i++)
	      Branchtab [i * NUMSTATES / 2 + state] =
	                     (polys[i] < 0) ^
	                        parity((2 * state) & abs (polys[i])) ? 255 : 0;
	}
}

//
//
//	The main use of the viterbi decoder is in handling the FIC blocks
//	There are (in mode 1) 3 ofdm blocks, giving 4 FIC blocks
//	There all have a predefined length. In that case we use the
//	"fast" (i.e. spiral) code, otherwise we use the generic code
void initViterbi768 (struct v *vp, int16_t wordlength) {
#ifdef	__MINGW32__
uint32_t	size;
#endif

	vp->frameBits		= wordlength;

// B I G N O T E	The spiral code uses (wordLength + (VITERBI_K - 1) * sizeof ...
// However, the application then crashes, so something is not OK
// By doubling the size, the problem disappears. It is not solved though
// and not further investigation.
#ifdef __MINGW32__
	size = 2 * ((wordlength + (VITERBI_K - 1)) / 8 + 1 + 16) & ~0xF;
	vp->data	= (uint8_t *)_aligned_malloc (size, 16);
	size = 2 * (RATE * (wordlength + (VITERBI_K - 1)) * sizeof(COMPUTETYPE) + 16) & ~0xF;
	vp->symbols	= (COMPUTETYPE *)_aligned_malloc (size, 16);
	size	= 2 * (wordlength + (VITERBI_K - 1)) * sizeof (decision_t);	
	size	= (size + 16) & ~0xF;
	vp->decisions = (decision_t  *)_aligned_malloc (size, 16);
#else
	if (posix_memalign ((void**)&vp->data, 16,
	                        (wordlength + (VITERBI_K - 1))/ 8 + 1)){
	   printf("Allocation of data array failed\n");
	}
	if (posix_memalign ((void**)&vp->symbols, 16,
	                     2* (RATE * (wordlength + (VITERBI_K - 1)) * sizeof(COMPUTETYPE)))){
	   printf("Allocation of symbols array failed\n");
	}
	if (posix_memalign ((void**)&(vp->decisions),
	                    16,
	                    2 * (wordlength + (VITERBI_K - 1)) * sizeof (decision_t))){
	   printf ("Allocation of vp decisions failed\n");
	}
#endif

//
	init_viterbi (vp, 0);
}


void destroyViterbi768	(struct v *vp) {
#ifdef	__MINGW32__
	_aligned_free (vp->decisions);
	_aligned_free (vp->data);
	_aligned_free (vp->symbols);
#else
	free (vp->decisions);
	free (vp->data);
	free (vp->symbols);
#endif
}

static int maskTable [] = {128, 64, 32, 16, 8, 4, 2, 1};
static  inline
uint8_t getbit (uint8_t v, int32_t o) {
        return  (v & maskTable [o]) ? 1 : 0;
}

//static
//uint8_t getbit (uint8_t v, int32_t o) {
//uint8_t	mask	= 1 << (7 - o);
//	return  (v & mask) ? 1 : 0;
//}
	
// depends: POLYS, RATE, COMPUTETYPE
// 	encode was only used for testing purposes
//void encode (/*const*/ unsigned char *bytes, COMPUTETYPE *symbols, int nbits) {
//int	i, k;
//int	polys [RATE] = POLYS;
//int	sr = 0;
//
//// FIXME: this is slowish
//// -- remember about the padding!
//	for (i = 0; i < nbits + (VITERBI_K - 1); i++) {
//	   int b = bytes[i/8];
//	   int j = i % 8;
//	   int bit = (b >> (7-j)) & 1;
//
//	   sr = (sr << 1) | bit;
//	   for (k = 0; k < RATE; k++)
//	      *(symbols++) = parity(sr & polys[k]);
//	}
//}

//	Note that our DAB environment maps the softbits to -127 .. 127
//	we have to map that onto 0 .. 255

#ifdef TRACE_VITERBI
static int temp_file_i = 0;
#endif

void	deconvolve	(struct v * vp, int16_t *input, uint8_t *output) {
uint32_t	i;
#ifdef TRACE_VITERBI
        char* filename = malloc(256);
#endif

	init_viterbi (vp, 0);
	for (i = 0; i < (uint16_t)(vp->frameBits + (VITERBI_K - 1)) * RATE; i ++) {
	   int16_t temp = input [i] + 127;
	   if (temp < 0) temp = 0;
	   if (temp > 255) temp = 255;
	   vp->symbols [i] = temp;
	}
	update_viterbi_blk_SPIRAL (vp, vp->symbols, vp->frameBits + (VITERBI_K - 1));

	chainback_viterbi (vp, vp->frameBits, 0);

	for (i = 0; i < (uint16_t)vp->frameBits; i ++)
	   output [i] = getbit (vp->data [i >> 3], i & 07);
	   
#ifdef TRACE_VITERBI
        snprintf(filename, 256, "/tmp/input%d", temp_file_i);
        FILE *pFile = fopen (filename, "wb");
        fwrite (input, 2, 3072 + 24, pFile);
        fclose (pFile);
        snprintf(filename, 256, "/tmp/output%d", temp_file_i++);
        pFile = fopen (filename, "wb");
        fwrite (output, 1, frameBits, pFile);
        fclose (pFile);
        free(filename);
#endif
}

#if defined(SSE_AVAILABLE)
void FULL_SPIRAL_sse (int,
#elif defined(CONFIG_NEON)
void FULL_SPIRAL_neon (int,
#else
void FULL_SPIRAL_no_sse (int,
#endif
	                 COMPUTETYPE *Y,
	                 COMPUTETYPE *X,
	                 COMPUTETYPE *syms,
	                 DECISIONTYPE *dec,
	                 COMPUTETYPE *Branchtab);

void	update_viterbi_blk_SPIRAL (struct v *vp,
					        COMPUTETYPE *syms,
					        int16_t nbits){
decision_t *d = (decision_t *)vp -> decisions;
int32_t s;

	for (s = 0; s < nbits; s++)
	   memset (d + s, 0, sizeof(decision_t));

#if defined(SSE_AVAILABLE)
	FULL_SPIRAL_sse (nbits,
#elif defined(CONFIG_NEON)
	FULL_SPIRAL_neon (nbits,
#else
	FULL_SPIRAL_no_sse (nbits,
#endif
	                 vp -> new_metrics -> t,
	                 vp -> old_metrics -> t,
	                 syms,
	                 d -> t, Branchtab);
}

//
/* Viterbi chainback */
void	chainback_viterbi (struct v *vp,
	                            int16_t nbits, /* Number of data bits */
	                            uint16_t endstate){ /*Terminal encoder state */
decision_t *d = vp -> decisions;

/* Make room beyond the end of the encoder register so we can
 * accumulate a full byte of decoded data
 */
	endstate = (endstate % NUMSTATES) << ADDSHIFT;
/* The store into data[] only needs to be done every 8 bits.
 * But this avoids a conditional branch, and the writes will
 * combine in the cache anyway
 */
	d += (VITERBI_K - 1); /* Look past tail */
	while (nbits-- != 0){
	   int k;
//	   int l	= (endstate >> ADDSHIFT) / 32;
//	   int m	= (endstate >> ADDSHIFT) % 32;
	   k = (d [nbits].w [(endstate >> ADDSHIFT) / 32] >>
	                       ((endstate>>ADDSHIFT) % 32)) & 1;
	   endstate = (endstate >> 1) | (k << (VITERBI_K - 2 + ADDSHIFT));
	   vp->data [nbits >> 3] = endstate >> SUBSHIFT;
	}
}

/* Initialize Viterbi decoder for start of new frame */
void 	init_viterbi (struct v *p, int16_t starting_state){
struct v *vp = p;
int32_t i;

	for (i = 0; i < NUMSTATES; i++)
	   vp -> metrics1.t[i] = 63;

	vp -> old_metrics = &vp -> metrics1;
	vp -> new_metrics = &vp -> metrics2;
/* Bias known start state */
	vp -> old_metrics-> t[starting_state & (NUMSTATES-1)] = 0;
}

